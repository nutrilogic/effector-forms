{"version":3,"file":"index.js","sources":["../src/create-form-unit.ts","../src/field.ts","../src/validation.ts","../src/factory.ts","../src/react-hooks.ts"],"sourcesContent":["import { createStore, createEvent, Domain, Store, Event } from \"effector\"\n\ntype CreateStoreParams<Value> = {\n  init: Value\n  domain?: Domain\n  existing?: Store<Value>\n}\n\nfunction store<Value>(\n    { init, domain, existing }: CreateStoreParams<Value>,\n    effectorData?: any\n) {\n    if (existing) {\n        return existing\n    }\n    return domain\n        ? domain.store(init, effectorData)\n        : createStore(init, effectorData)\n}\n\ntype CreateEventParams<Value> = {\n  domain?: Domain\n  existing?: Event<Value>\n}\n\nfunction event<Value>({ domain, existing }: CreateEventParams<Value>) {\n    if (existing) {\n        return existing\n    }\n    return domain ? domain.event<Value>() : createEvent<Value>()\n}\n\nexport const createFormUnit = {\n    store,\n    event,\n}\n","import {\n    createStore,\n    Domain,\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n    merge,\n} from \"effector\"\nimport {\n    ValidationError,\n    Field,\n    FieldData,\n    FieldConfig,\n    AnyFormValues,\n    ValidationEvent,\n    Rule,\n    RuleResolver,\n} from \"./types\"\nimport { createCombineValidator } from \"./validation\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nexport function createField(\n    fieldName: string,\n    fieldConfig: FieldConfig<any>,\n    domain?: Domain,\n): Field<any> {\n    const initValue = typeof fieldConfig.init === \"function\"\n        ? fieldConfig.init()\n        : fieldConfig.init\n\n    const $initialValue = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$initialValue,\n        init: initValue,\n    }, { sid: `${fieldName}-initialValue`})\n    const $value = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$value,\n        init: initValue,\n    }, { sid: `${fieldName}-value`})\n\n    const $errors = createFormUnit.store<ValidationError[]>({\n        domain,\n        existing: fieldConfig.units?.$errors,\n        init: [],\n    }, { sid: `${fieldName}-errors`})\n\n\n    const $firstError = $errors.map(\n        (errors) => errors[0] ? errors[0] : null\n    )\n\n    const $isDirty = combine($initialValue, $value, \n        (initialValue, value) => value !== initialValue\n    )\n\n    const $touched = createFormUnit.store({\n        domain,\n        existing: fieldConfig.units?.$isTouched,\n        init: false,\n    }, `${fieldName}-initialValue`)\n\n    const onChange = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onChange,\n    })\n    const onBlur = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.onBlur,\n    })\n    const changed = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.changed,\n    })\n    const addError = createFormUnit.event<{\n        rule: string\n        errorText?: string\n    }>({\n        domain,\n        existing: fieldConfig.units?.addError,\n    })\n    const validate = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.validate,\n    })\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetErrors,\n    })\n    const resetValue = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.resetValue,\n    })\n    const reset = createFormUnit.event({\n        domain,\n        existing: fieldConfig.units?.reset,\n    })\n\n    const $isValid = $firstError.map((firstError) => firstError === null)\n\n    const $field = combine({\n        value: $value,\n        errors: $errors,\n        firstError: $firstError,\n        isValid: $isValid,\n        isDirty: $isDirty,\n        isTouched: $touched,\n    })\n\n    return {\n        changed,\n        name: fieldName,\n        $initialValue,\n        $value,\n        $errors,\n        $firstError,\n        $isValid,\n        $isDirty,\n        $isTouched: $touched,\n        $touched,\n        $field: $field as Store<FieldData<any>>,\n        onChange,\n        onBlur,\n        addError,\n        validate,\n        set: onChange,\n        reset,\n        resetErrors,\n        resetValue,\n        filter: fieldConfig.filter,\n    }\n}\n\ntype BindValidationParams = {\n    $form: Store<AnyFormValues>\n    validateFormEvent: Event<void>\n    submitEvent: Event<void>\n    resetFormEvent: Event<void>\n    resetValues: Event<void>\n    resetErrors: Event<void>\n    field: Field<any>\n    rules: Rule<any, any>[] | RuleResolver<any, any>\n    formValidationEvents: ValidationEvent[]\n    fieldValidationEvents: ValidationEvent[]\n}\n\nexport function bindValidation({\n    $form,\n    validateFormEvent,\n    submitEvent,\n    resetFormEvent,\n    resetValues,\n    field,\n    rules,\n    resetErrors: resetErrorsFormEvent,\n    formValidationEvents,\n    fieldValidationEvents,\n}: BindValidationParams,\neffectorData?: any): void {\n    const {\n        $value,\n        $errors,\n        onBlur,\n        changed,\n        addError,\n        validate,\n        resetErrors,\n        resetValue,\n        reset,\n    } = field\n\n    const rulesSources = typeof rules === \"function\"\n        ? createStore<any[]>([], effectorData)\n        : combine(\n            rules.map(({ source }) => source || createStore(null, effectorData))\n        )\n\n    const validator = createCombineValidator(rules)\n    const eventsNames = [...formValidationEvents, ...fieldValidationEvents]\n    const validationEvents: Event<{\n        fieldValue: any\n        form: AnyFormValues\n        rulesSources: any[]\n    }>[] = []\n\n    if (eventsNames.includes(\"submit\")) {\n        const validationTrigger = sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: submitEvent,\n        })\n\n        validationEvents.push(validationTrigger)\n    }\n\n    if (eventsNames.includes(\"blur\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: onBlur,\n        }))\n    }\n\n    if (eventsNames.includes(\"change\")) {\n        validationEvents.push(sample({\n            source: combine({\n                fieldValue: $value,\n                form: $form,\n                rulesSources,\n            }),\n            clock: merge(\n                [changed, resetValue, resetValues]\n            ),\n        }))\n    }\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n            rulesSources,\n        }),\n        clock: validate,\n    }))\n\n    validationEvents.push(sample({\n        source: combine({\n            fieldValue: $value,\n            form: $form,\n            rulesSources,\n        }),\n        clock: validateFormEvent,\n    }))\n\n    const addErrorWithValue = sample({\n        source: $value,\n        clock: addError,\n        fn: (value, { rule, errorText }): ValidationError => ({\n            rule,\n            value,\n            errorText,\n        }),\n    })\n\n    $errors\n        .on(\n            validationEvents,\n            (_, { form, fieldValue, rulesSources }) => validator(\n                fieldValue,\n                form,\n                rulesSources,\n            )\n        )\n        .on(addErrorWithValue, (errors, newError) => [newError, ...errors])\n        .reset(resetErrors, resetFormEvent, reset, resetErrorsFormEvent)\n\n    if (!eventsNames.includes(\"change\")) {\n        $errors.reset(changed)\n    }\n}\n\nexport function bindChangeEvent(\n    {\n        $initialValue,\n        $value,\n        $touched,\n        onChange,\n        changed,\n        name,\n        reset,\n        resetValue,\n        filter }: Field<any>,\n    setForm: Event<Partial<AnyFormValues>>,\n    resetForm: Event<void>,\n    resetTouched: Event<void>,\n    resetValues: Event<void>,\n    setInitial: Event<Partial<AnyFormValues>>,\n): void {\n\n    $touched\n        .on(changed, () => true)\n        .reset(reset, resetForm, resetTouched)\n\n    guard({\n        source: onChange,\n        filter: filter || (() => true),\n        target: changed,\n    })\n\n    $initialValue.on(\n        setInitial,\n        (curr, updateSet) => updateSet.hasOwnProperty(name)\n            ? updateSet[name]\n            : curr\n    )\n\n    sample({\n        clock: [reset, resetValue, resetValues, resetForm],\n        source: $initialValue,\n        target: $value,\n    })\n\n    $value\n        .on(changed, (_, value) => value)\n        .on(\n            setForm,\n            (curr, updateSet) => updateSet.hasOwnProperty(name)\n                ? updateSet[name]\n                : curr\n        )\n}\n","import { Store, combine } from \"effector\"\nimport {\n    ValidationError,\n    Rule,\n    AnyFields,\n    RuleResolver,\n} from \"./types\"\n\nexport function createCombineValidator<Value = any, Form = any>(\n    rulesOrResolver: Rule<Value, Form, any>[] | RuleResolver<Value, Form>\n) {\n    return (\n        value: Value,\n        form: Form,\n        rulesSources?: any[]\n    ): ValidationError<Value>[] => {\n\n        const errors: ValidationError<Value>[] = []\n        const rules = typeof rulesOrResolver === \"function\"\n            ? rulesOrResolver(value, form)\n            : rulesOrResolver\n\n        for (let i = 0; i < rules.length; i++) {\n            const rule = rules[i]\n            const source = rulesSources ? rulesSources[i] : null\n            const result = rule.validator(value, form, source)\n\n            if (typeof result === \"boolean\" && !result) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: rule.errorText,\n                    value,\n                })\n            }\n\n            if (typeof result === \"object\" && !result.isValid) {\n                errors.push({\n                    rule: rule.name,\n                    errorText: result.errorText,\n                    value,\n                })\n            }\n        }\n\n        return errors\n    }\n}\n\n\nexport function eachValid(fields: AnyFields) {\n    const firstErrors: Store<ValidationError | null>[] = []\n  \n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        const { $firstError } = fields[fieldName]\n        firstErrors.push($firstError)\n    }\n  \n    const $firstErrors = combine(firstErrors)\n  \n    return $firstErrors.map((errors) => errors.every(error => error === null))\n}\n","import {\n    Event,\n    Store,\n    combine,\n    sample,\n    guard,\n} from \"effector\"\nimport {\n    AnyFields,\n    AnyFormValues,\n    FormConfig,\n    Form,\n} from \"./types\"\nimport { eachValid } from \"./validation\"\nimport {\n    createField,\n    bindValidation,\n    bindChangeEvent,\n} from \"./field\"\nimport { createFormUnit } from \"./create-form-unit\"\n\nfunction createFormValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$value\n    }\n\n    return combine(shape)\n}\n\nfunction createFormInitialValuesStore(\n    fields: AnyFields\n): Store<AnyFormValues> {\n    const shape: { [key: string]: Store<any> } = {}\n\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n        shape[fieldName] = fields[fieldName].$initialValue\n    }\n\n    return combine(shape)\n}\n\nexport function createForm<Values extends AnyFormValues>(\n    config: FormConfig<Values>\n) {\n    const {\n        filter: $filter,\n        domain,\n        fields: fieldsConfigs,\n        validateOn,\n        units,\n    } = config\n\n    const fields: AnyFields = {}\n\n    const dirtyFlagsArr: Store<boolean>[] = []\n    const touchedFlagsArr: Store<boolean>[] = []\n\n    // create units\n    for (const fieldName in fieldsConfigs) {\n        if (!fieldsConfigs.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n\n        const field = createField(fieldName, fieldConfig, domain)\n\n        fields[fieldName] = field\n        dirtyFlagsArr.push(field.$isDirty)\n        touchedFlagsArr.push(field.$touched)\n    }\n\n    const $form = createFormValuesStore(fields)\n    const $initialValues = createFormInitialValuesStore(fields)\n\n    const $eachValid = eachValid(fields)\n    const $isFormValid = $filter\n        ? combine($eachValid, $filter, (valid, filter) => valid && filter)\n        : $eachValid\n    const $isDirty = combine(dirtyFlagsArr).map(\n        (dirtyFlags) => dirtyFlags.some(Boolean)\n    )\n    const $touched = combine(touchedFlagsArr).map(\n        (touchedFlags) => touchedFlags.some(Boolean)\n    )\n\n    const $meta = combine({\n        isValid: $eachValid,\n        isDirty: $isDirty,\n        touched: $touched,\n    })\n\n    const validate = createFormUnit.event<void>({\n        domain,\n        existing: units?.validate,\n    })\n\n    const submitForm = createFormUnit.event<void>({\n        domain,\n        existing: units?.submit,\n    })\n\n    const formValidated = createFormUnit.event({\n        domain,\n        existing: units?.formValidated,\n    })\n\n    const setInitial = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setInitial as Event<Partial<AnyFormValues>>,\n    })\n\n    const setForm = createFormUnit.event<Partial<AnyFormValues>>({\n        domain,\n        existing: units?.setForm as Event<Partial<AnyFormValues>>,\n    })\n\n    const resetForm = createFormUnit.event({\n        domain,\n        existing: units?.reset,\n    })\n\n    const resetValues = createFormUnit.event({\n        domain,\n        existing: units?.resetValues,\n    })\n\n    const resetErrors = createFormUnit.event({\n        domain,\n        existing: units?.resetErrors,\n    })\n\n    const resetTouched = createFormUnit.event({\n        domain,\n        existing: units?.resetTouched,\n    })\n\n    const submitWithFormData = sample({\n        source: $form,\n        clock: submitForm,\n    })\n    const validateWithFormData = sample({\n        source: $form,\n        clock: validate\n    })\n\n    // bind units\n    for (const fieldName in fields) {\n        if (!fields.hasOwnProperty(fieldName)) continue\n\n        const fieldConfig = fieldsConfigs[fieldName]\n        const field = fields[fieldName]\n\n        bindChangeEvent(\n            field, \n            setForm, \n            resetForm,\n            resetTouched, \n            resetValues,\n            setInitial, \n        )\n\n        if (!fieldConfig.rules) continue\n\n        bindValidation({\n            $form,\n            rules: fieldConfig.rules,\n            submitEvent: submitForm,\n            resetFormEvent: resetForm,\n            resetValues,\n            resetErrors,\n            validateFormEvent: validate,\n            field,\n            formValidationEvents: validateOn ? validateOn : [\"submit\"],\n            fieldValidationEvents: fieldConfig.validateOn\n                ? fieldConfig.validateOn\n                : [],\n        }, { sid: fieldName })\n    }\n\n    guard({\n        source: submitWithFormData as unknown as Event<Values>,\n        filter: $isFormValid,\n        // TODO: fix\n        target: formValidated,\n    })\n\n    guard({\n        source: validateWithFormData as unknown as Event<Values>,\n        filter: $isFormValid,\n        target: formValidated,\n    })\n\n    return {\n        fields,\n        $values: $form,\n        $initialValues,\n        $eachValid,\n        $isValid: $eachValid,\n        $isDirty: $isDirty,\n        $touched: $touched,\n        $meta,\n        submit: submitForm,\n        validate,\n        resetTouched,\n        reset: resetForm,\n        resetValues,\n        resetErrors,\n        setInitial,\n        setForm,\n        set: setForm,\n        formValidated,\n    } as unknown as Form<Values>\n}\n","import { useUnit } from \"effector-react\"\nimport {\n    Field,\n    ValidationError,\n    AnyFormValues,\n    Form\n} from \"./types\"\n\ntype ErrorTextMap = {\n  [key: string]: string\n}\n\ntype AddErrorPayload = { rule: string; errorText?: string }\n\ntype ConnectedField<Value> = {\n  name: string\n  value: Value\n  errors: ValidationError<Value>[]\n  firstError: ValidationError<Value> | null\n  hasError: () => boolean\n  onChange: (v: Value) => Value\n  onBlur: (v: void) => void\n  errorText: (map?: ErrorTextMap) => string\n  addError: (p: AddErrorPayload) => AddErrorPayload\n  validate: (v: void) => void\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  reset: (v: void) => void\n  set: (v: Value) => Value\n  resetErrors: (v: void) => void\n}\n\ntype ConnectedFields<Values extends AnyFormValues> = {\n  [K in keyof Values]: ConnectedField<Values[K]>\n}\n\ntype AnyConnectedFields = {\n  [key: string]: ConnectedField<any>\n}\n\nexport function useField<Value>(field: Field<Value>): ConnectedField<Value> {\n    const {\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        isTouched: touched,\n    } = useUnit(field.$field)\n\n    return {\n        name: field.name,\n        value,\n        errors,\n        firstError,\n        isValid,\n        isDirty,\n        touched,\n        isTouched: touched,\n        onChange: useUnit(field.onChange),\n        onBlur: useUnit(field.onBlur),\n        addError: useUnit(field.addError),\n        validate: useUnit(field.validate),\n        reset: useUnit(field.reset),\n        set: useUnit(field.onChange),\n        resetErrors: useUnit(field.resetErrors),\n        hasError: () => {\n            return firstError !== null\n        },\n        errorText: (map) => {\n            if (!firstError) {\n                return \"\"\n            }\n            if (!map) {\n                return firstError.errorText || \"\"\n            }\n            if (map[firstError.rule]) {\n                return map[firstError.rule]\n            }\n            return firstError.errorText || \"\"\n        }\n    }\n\n}\n\ntype Result<Values extends AnyFormValues> = {\n  fields: ConnectedFields<Values>\n  values: Values\n  hasError: (fieldName?: keyof Values) => boolean\n  eachValid: boolean\n  isValid: boolean\n  isDirty: boolean\n  isTouched: boolean\n  touched: boolean\n  errors: (fieldName: keyof Values) => (\n    ValidationError<Values[typeof fieldName]>[]\n  )\n  error: (fieldName: keyof Values) => (\n    ValidationError<Values[typeof fieldName]>\n  ) | null\n  errorText: (fieldName: keyof Values, map?: ErrorTextMap) => string\n  submit: (p: void) => void\n  reset: (p: void) => void\n  setInitial: (p: Partial<Values>) => Partial<Values>\n  setForm: (p: Partial<Values>) => Partial<Values>\n  set: (p: Partial<Values>) => Partial<Values>\n  formValidated: (p: Values) => Values\n}\n\nexport function useForm<Values extends AnyFormValues>(\n    form: Form<Values>\n): Result<Values> {\n    const connectedFields = {} as AnyConnectedFields\n    const values = {} as AnyFormValues\n\n    for (const fieldName in form.fields) {\n        if (!form.fields.hasOwnProperty(fieldName)) continue\n        const field = form.fields[fieldName]\n        const connectedField = useField(field)\n        connectedFields[fieldName] = connectedField\n        values[fieldName] = connectedField.value\n    }\n\n    const {\n        isValid: eachValid,\n        isDirty,\n        touched,\n    } = useUnit(form.$meta)\n\n\n    const hasError = (fieldName?: string): boolean => {\n        if (!fieldName) {\n            return !eachValid\n        }\n        if (connectedFields[fieldName]) {\n            return Boolean(connectedFields[fieldName].firstError)\n        }\n        return false\n    }\n\n    const error = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].firstError\n        }\n        return null\n    }\n\n    const errors = (fieldName: string) => {\n        if (connectedFields[fieldName]) {\n            return connectedFields[fieldName].errors\n        }\n        return []\n    }\n\n    const errorText = (fieldName: string, map?: ErrorTextMap) => {\n        const field = connectedFields[fieldName]\n        if (!field) {\n            return \"\"\n        }\n        if (!field.firstError) {\n            return \"\"\n        }\n        if (!map) {\n            return field.firstError.errorText || \"\"\n        }\n        if (map[field.firstError.rule]) {\n            return map[field.firstError.rule]\n        }\n        return field.firstError.errorText || \"\"\n    }\n\n    return {\n        fields: connectedFields as ConnectedFields<Values>,\n        values,\n        hasError,\n        eachValid,\n        isValid: eachValid,\n        isDirty,\n        isTouched: touched,\n        touched,\n        errors,\n        error,\n        errorText,\n        reset: useUnit(form.reset),\n        setInitial: useUnit(form.setInitial),\n        submit: useUnit(form.submit),\n        setForm: useUnit(form.setForm),\n        set: useUnit(form.setForm), // set form alias\n        formValidated: useUnit(form.formValidated),\n    } as Result<Values>\n}\n"],"names":["createFormUnit","store","init","domain","existing","effectorData","and","sid","createStore","event","createEvent","createField","fieldName","fieldConfig","_fieldConfig$units","_fieldConfig$units2","_fieldConfig$units3","_fieldConfig$units4","_fieldConfig$units5","_fieldConfig$units6","_fieldConfig$units7","_fieldConfig$units8","_fieldConfig$units9","_fieldConfig$units10","_fieldConfig$units11","_fieldConfig$units12","initValue","$initialValue","units","name","$value","$errors","$firstError","map","errors","$isDirty","combine","initialValue","value","or","$touched","$isTouched","onChange","onBlur","changed","addError","validate","resetErrors","resetValue","reset","$isValid","firstError","$field","isValid","isDirty","isTouched","set","filter","bindValidation","$form","validateFormEvent","submitEvent","resetFormEvent","resetValues","field","rules","resetErrorsFormEvent","formValidationEvents","fieldValidationEvents","rulesSources","source","validator","rulesOrResolver","form","i","length","rule","result","push","errorText","eventsNames","validationEvents","includes","validationTrigger","sample","fieldValue","clock","merge","addErrorWithValue","fn","on","_","newError","bindChangeEvent","setForm","resetForm","resetTouched","setInitial","guard","target","curr","updateSet","hasOwnProperty","createForm","config","$filter","fields","fieldsConfigs","validateOn","dirtyFlagsArr","touchedFlagsArr","_withFactory","method","shape","createFormValuesStore","$initialValues","createFormInitialValuesStore","$eachValid","firstErrors","every","error","eachValid","$isFormValid","valid","dirtyFlags","some","Boolean","touchedFlags","$meta","touched","submitForm","submit","formValidated","submitWithFormData","validateWithFormData","$values","useField","useUnit","hasError","useForm","connectedFields","values","connectedField"],"mappings":"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"}